function main() {
  const sheetName = 'data'; 
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(sheetName);

  if (!sheet) {
    Logger.log("【エラー】シート「" + sheetName + "」が見つかりません。");
    return;
  }
  
  // ▼▼▼ 営業日・重複チェック（ここから） ▼▼▼
  var checkDate = new Date(); 
  var checkDay = checkDate.getDay(); // 0:日, 1:月... 6:土

  // 1. 土日の場合は終了
  if (checkDay === 0 || checkDay === 6) {
    Logger.log("今日は土日のためスキップします");
    return;
  }

  // 2. 祝日チェック（クリスマス等の記念日を除外するロジック追加）
  var calendarId = 'ja.japanese#holiday@group.v.calendar.google.com';
  var holidays = CalendarApp.getCalendarById(calendarId).getEventsForDay(checkDate);
  
  // カレンダーに予定がある場合、それが「市場が休みになる祝日」かチェック
  if (holidays.length > 0) {
    var isMarketHoliday = false;
    for (var i = 0; i < holidays.length; i++) {
      var title = holidays[i].getTitle();
      // イベント名に「クリスマス」が含まれていない場合のみ、休みとする
      if (title.indexOf('クリスマス') === -1) {
        Logger.log("今日は祝日(" + title + ")のためスキップします");
        isMarketHoliday = true;
        break;
      }
    }
    // 本当の祝日だった場合は終了
    if (isMarketHoliday) {
      return;
    }
  }

  // 3. 年末年始(12/31 ～ 1/3)チェック
  // 日本株は12/31も休場です
  var m = checkDate.getMonth() + 1;
  var d = checkDate.getDate();
  if ((m === 1 && d <= 3) || (m === 12 && d === 31)) {
    Logger.log("年末年始休みのためスキップします");
    return;
  }

  // 4. 重複チェック（今日の分がすでにA列の最後にあったら終了）
  var lastRow = sheet.getLastRow();
  if (lastRow > 0) { 
    var lastDateVal = sheet.getRange(lastRow, 1).getValue(); 
    var lastDate = new Date(lastDateVal);
    
    // 「最後の行の日付」と「今日」が同じ年月日なら終了
    if (
      lastDate.getFullYear() === checkDate.getFullYear() &&
      lastDate.getMonth() === checkDate.getMonth() &&
      lastDate.getDate() === checkDate.getDate()
    ) {
      Logger.log("本日のデータは既に存在するためスキップします");
      return;
    }
  }
  // ▲▲▲ 営業日・重複チェック（ここまで） ▲▲▲

  // ▼▼▼ 日付と曜日を作成する処理 ▼▼▼
  const today = new Date();
  const weekDays = ['日', '月', '火', '水', '木', '金', '土'];
  const dayStr = weekDays[today.getDay()]; 
  
  const formattedDate = Utilities.formatDate(today, 'Asia/Tokyo', 'yyyy/MM/dd') + '(' + dayStr + ')';
  // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

  Logger.log("処理開始: " + formattedDate);

  // 1. ストップ高の取得
  const sHighUrl = 'https://kabutan.jp/warning/?mode=3_1';
  const sHighData = scrapeKabutanStopAllocation(sHighUrl, 'S高');
  if (sHighData.length > 0) {
    writeToSheet(sheet, sHighData, formattedDate);
  }

  Utilities.sleep(2000); 

  // 2. ストップ安の取得
  const sLowUrl = 'https://kabutan.jp/warning/?mode=3_2';
  const sLowData = scrapeKabutanStopAllocation(sLowUrl, 'S安');
  if (sLowData.length > 0) {
    writeToSheet(sheet, sLowData, formattedDate);
  }

  // 3. デザイン適用
  applyFinalStyle(sheet);

  Logger.log("処理完了");
}

// デザイン・色・配置を一括適用する関数（幅固定版）
function applyFinalStyle(sheet) {
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();

  if (lastRow < 1) return;

  const range = sheet.getRange(1, 1, lastRow, lastCol);

  // --- A. 基本設定 ---
  range.setFontColor("black"); 
  range.setFontSize(12);
  range.setFontFamily("Roboto"); 
  sheet.setRowHeights(1, lastRow, 25); 
  
  range.setBorder(true, true, true, true, true, true, '#d9d9d9', SpreadsheetApp.BorderStyle.SOLID);
  
  // ★幅固定の設定★
  sheet.setColumnWidth(1, 160); // A列: 日付
  sheet.setColumnWidth(2, 60);  // B列: 状態
  sheet.setColumnWidth(3, 60);  // C列: コード
  sheet.setColumnWidth(4, 250); // D列: 銘柄名
  sheet.setColumnWidth(5, 80);  // E列: 現在値
  sheet.setColumnWidth(6, 80);  // F列: 前日比

  // --- B. フィルター設定 ---
  if (sheet.getFilter() !== null) {
    sheet.getFilter().remove();
  }
  range.createFilter();

  // --- C. ヘッダーのデザイン ---
  const headerRange = sheet.getRange(1, 1, 1, lastCol);
  headerRange.setBackground("#A0522D"); 
  headerRange.setFontColor("white");    
  headerRange.setFontWeight("bold");
  headerRange.setHorizontalAlignment("center");

  // 縞模様
  const bandings = sheet.getBandings();
  for (let i = 0; i < bandings.length; i++) {
    bandings[i].remove();
  }
  range.applyRowBanding(SpreadsheetApp.BandingTheme.PINK);

  // --- D. 条件付き書式 ---
  sheet.clearConditionalFormatRules();
  const rules = [];

  rules.push(SpreadsheetApp.newConditionalFormatRule()
    .whenTextContains("S高").setFontColor("#CC0000").setBold(true).setRanges([range]).build());

  rules.push(SpreadsheetApp.newConditionalFormatRule()
    .whenTextContains("S安").setFontColor("#0000CC").setBold(true).setRanges([range]).build());

  rules.push(SpreadsheetApp.newConditionalFormatRule()
    .whenTextStartsWith("+").setFontColor("#CC0000").setRanges([range]).build());

  rules.push(SpreadsheetApp.newConditionalFormatRule()
    .whenTextStartsWith("-").setFontColor("#0000CC").setRanges([range]).build());

  sheet.setConditionalFormatRules(rules);

  Logger.log("デザイン適用完了");
}

function scrapeKabutanStopAllocation(url, type) {
  try {
    const options = {
      'method': 'get',
      'headers': {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      },
      'muteHttpExceptions': true
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const html = response.getContentText();
    const rows = html.split('</tr>');
    const data = [];

    for (let i = 0; i < rows.length; i++) {
      const rowHtml = rows[i];
      if (rowHtml.indexOf('code=') === -1) continue;

      const cells = rowHtml.split('</td>');
      const texts = cells.map(cell => {
         return cell.replace(/<[^>]+>/g, "")
                    .replace(/&nbsp;/g, "")
                    .replace(/[\r\n\t ]+/g, " ")
                    .trim();
      }).filter(t => t !== ""); 

      let code = "";
      let name = "";
      let price = "";
      let change = "";

      const codeIndex = texts.findIndex(t => /^[0-9A-Z]{4}$/.test(t));
      
      if (codeIndex !== -1) {
        code = texts[codeIndex];
        if (texts.length > codeIndex + 1) {
          name = texts[codeIndex + 1];
        }
        for (let k = codeIndex + 2; k < texts.length; k++) {
          let t = texts[k];
          let cleanPrice = t.replace(/ S$/, "").replace("S", "").trim();

          if (/^[0-9,]+$/.test(cleanPrice) && cleanPrice !== "") {
            price = cleanPrice;
            for (let m = k + 1; m < texts.length; m++) {
               if (/^[+\-][0-9,]+/.test(texts[m])) {
                 change = texts[m].split(' ')[0]; 
                 break;
               }
            }
            break;
          }
        }
      }

      if (code && name && price) {
        data.push([type, code, name, price, change]);
      }
    }
    return data;

  } catch (e) {
    Logger.log('エラー: ' + e);
    return [];
  }
}

function writeToSheet(sheet, data, date) {
  const rows = data.map(row => [date, ...row]);
  if (rows.length > 0) {
    sheet.getRange(sheet.getLastRow() + 1, 1, rows.length, rows[0].length).setValues(rows);
  }
}

// ▼▼▼ WEB公開用（Webサイトにデータを渡すための関数） ▼▼▼
function doGet() {
  const sheetName = 'data'; 
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
  
  if (!sheet) {
    return ContentService.createTextOutput(JSON.stringify({error: "Sheet not found"}))
      .setMimeType(ContentService.MimeType.JSON);
  }

  const data = sheet.getDataRange().getValues();
  
  const formattedData = data.map((row, index) => {
    // ヘッダー行はそのまま
    if (index === 0) return row;
    
    // 日付オブジェクトを文字列(yyyy/MM/dd)に変換してJSONで化けないようにする
    if (row[0] instanceof Date) {
      row[0] = Utilities.formatDate(row[0], 'Asia/Tokyo', 'yyyy/MM/dd');
    }
    return row;
  });

  return ContentService.createTextOutput(JSON.stringify(formattedData))
    .setMimeType(ContentService.MimeType.JSON);
}
